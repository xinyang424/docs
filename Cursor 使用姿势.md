# Cursor 使用姿势

## 简介

本文档旨在提供 Cursor 编辑器的全面使用指南，从实际使用场景出发，帮助用户快速上手并掌握 Cursor 的强大功能。Cursor 是一款集成 AI 功能的现代代码编辑器，通过 Claude 和 GPT 等大语言模型，为开发者提供智能编码辅助。

本指南按功能模块划分，每个部分都包含使用场景和解决方案，让你能够根据实际需求找到合适的功能。由于篇幅有限，某些功能可能未详细阐述，建议结合文末的参考链接获取更多信息。

## Composer

Composer 是 Cursor 的核心 AI 编码助手，能够理解你的代码和意图，提供多种智能编码帮助：

- **代码生成与补全**
  - 智能生成完整代码片段（输入需求描述，Cursor 会提示可能的实现，按 Tab 即可应用）
  - 根据上下文自动补全函数和代码块（比手动编写更快更准确）
- **代码重构与优化**

  - 一键重构复杂代码（当你面对难以理解的复杂代码时，可让 AI 重新组织为清晰结构）
  - 性能优化建议（自动识别性能瓶颈和边界情况处理）
  - 统一代码风格（快速调整代码以符合项目规范或个人偏好）

- **文档生成**

  - 自动生成专业文档注释（JSDoc、TSDoc 等，为函数和类添加规范文档）
  - 一键创建 API 文档（为接口和服务生成详细说明）
  - 生成项目 README（快速创建包含安装、使用方法的项目说明文件）

- **代码解释**

  - 解析复杂代码逻辑（当你遇到难以理解的代码时，AI 能用通俗语言解释）
  - 提供工作原理详解（理解某个库或框架的实现机制）
  - 分析代码潜在问题（找出隐藏 bug 和优化空间）

- **上下文感知**
  - 自动理解项目结构（AI 能根据项目全局情况给出更契合的建议）
  - 考虑已有代码风格（生成的代码会与周围代码保持一致）
  - 保持项目一致性（遵循项目中已建立的模式和实践）
- **交互式开发**
  - 支持多轮对话式编码（逐步完善需求和实现，避免一次生成过多难以理解的代码）
  - 实时反馈与调整（对生成结果不满意时可以立即提出修改建议）
  - 渐进式代码完善（从基础框架开始，逐步添加复杂功能）
- **学习辅助**

  - 解释编程概念（像私人导师一样讲解你不熟悉的技术概念）
  - 提供系统化学习资源（比网上零散的教程更全面、更有条理）
  - 帮助理解复杂算法（将抽象算法用简单例子和图解方式说明）

- **多语言支持**

  - 支持几乎所有主流编程语言（JavaScript、Java、Python、Kotlin、C、Go 等）
  - 跨语言代码转换（如将 Java 代码转为 Kotlin，JavaScript 转为 TypeScript）

- **项目特定功能**

  - 自动分析项目结构（理解项目的组织方式和依赖关系）
  - 遵循项目规范（通过 Cursor Rules 确保生成的代码符合团队标准）
  - 生成匹配项目风格的代码（保持与现有代码库的一致性）

- **调试辅助**
  - 生成测试和调试代码（快速创建单元测试或调试用的代码片段）
  - 提供错误修复建议（分析错误信息并提出具体解决方案）
  - 帮助定位问题根源（追踪错误传播路径和原因）

## Add Context

Add Context 功能允许你向 AI 提供更多上下文信息，使其能更精准地理解你的需求和项目环境：

- **Files & folders**

  - 当你需要 AI 理解特定文件或项目结构时（如处理依赖关系或引用）
  - 处理多文件协作开发（如前后端接口对接、组件复用等跨文件操作）
  - 帮助 AI 了解整个项目架构（生成符合架构的新组件或功能）

- **Code**

  - 需要 AI 深入分析特定代码片段（如找出性能瓶颈或设计缺陷）
  - 进行代码重构和优化（将选中代码提供给 AI 进行改进）
  - 代码审查和质量评估（获取对代码质量的专业评价）
  - 提供代码优化建议（改进算法、减少重复代码等）

- **Docs**

  - 需要 AI 理解项目文档和规范（如 API 文档、开发规范等）
  - 自动生成或更新文档（保持代码和文档的一致性）
  - 处理和完善 API 文档（确保接口文档的完整性和准确性）
  - 撰写技术说明和使用指南（面向不同受众的技术文档）

- **Notepads**

  - 需要临时记录想法、提示词或代码片段（不必创建新文件就能保存临时内容）
  - 可在多个对话间共享信息和上下文（避免重复输入相同内容）
  - 保存常用提示模板和代码片段（创建个人的提示词库）
  - 整理开发思路和解决方案（头脑风暴和方案草稿）
  - 跨会话持久化重要信息（让重要信息在所有对话中都能访问）
  - 创建结构化的开发计划和任务列表（项目管理和进度跟踪）

- **Git**

  - 让 AI 分析代码变更和提交历史（理解代码演化过程）
  - 辅助代码审查（获取对提交内容的专业评价）
  - 分析版本历史找出问题（定位引入 bug 的提交）
  - 解决合并冲突（提供合理的冲突解决方案）

- **Past chats**

  - 引用之前的对话历史作为上下文（避免重复解释相同问题）
  - 继续之前未完成的讨论（无缝衔接上次的开发任务）
  - 参考历史解决方案（复用之前成功的方法）
  - 保持长期对话的连续性（长期项目开发的知识积累）

- **Cursor rules**

  - 设置 AI 需要遵循的特定规则（如编码风格、命名规范等）
  - 确保代码风格一致性（统一团队代码风格）
  - 强制执行项目规范（确保生成的代码符合项目要求）
  - 定义个性化的代码生成偏好（按自己习惯生成代码）

- **Terminals**

  - 让 AI 理解命令行输出和日志（分析构建错误和运行日志）
  - 获取命令行操作建议（学习常用命令和参数）
  - 分析构建过程中的问题（解决编译和打包错误）
  - 协助环境配置和依赖管理（解决环境问题）
  - 修复命令行错误（提供正确的命令格式和参数）

- **Linter errors**

  - 快速修复代码质量问题（选择错误信息获取即时修复方案）
  - 改进代码品质（根据 linter 规则优化代码）
  - 一键解决代码警告和错误（避免手动逐个修复）
  - 学习最佳编码实践（理解 linter 规则背后的原理）

- **Web**

  - 获取网络上的最新信息（如 API 文档、技术博客等）
  - 分析网页内容（提取网页中的关键信息）
  - 引用在线资源和教程（利用最新的技术资料）
  - 了解 API 使用方式（查询第三方服务的集成方法）

- **Recent changes**
  - 让 AI 了解你最近的代码修改（保持上下文连贯性）
  - 进行即时代码审查（获取对新修改的反馈）
  - 分析变更带来的影响（评估代码修改的潜在风险）
  - 追踪问题和修复过程（了解问题解决的历程）
  - 理解当前开发上下文（基于最近的工作进行下一步建议）
  - 进行变更分析和影响评估（确保修改不会破坏现有功能）

## Models

选择合适的 AI 模型对于高效使用 Cursor 至关重要。不同模型有不同的特长，根据任务复杂度和紧急程度灵活选择，让 AI 发挥最大效能，而不是自己费力操作。

- **Claude-3.7 Sonnet 适用场景**

  - 复杂代码生成与重构（处理大型或高复杂度的代码库）
  - 高级算法实现（当需要优化性能或实现特殊算法时）
  - 深度代码分析（需要 AI 透彻理解代码逻辑和架构）
  - 大型项目架构设计（系统级的架构规划和模块划分）
  - 高质量代码输出（对代码质量有严格要求的场景）
  - 复杂需求理解（当你的需求描述复杂或有多个约束条件时）

  **实际案例**：

  - "设计一个高并发的微服务架构，包含用户服务、订单服务和支付服务"
  - "重构这个有 300 行的复杂函数，将其分解为更小、更可测试的组件"
  - "分析这个项目的性能瓶颈并提供详细的优化方案"
  - "实现一个高效的图数据处理算法，需要考虑时间复杂度和空间复杂度"

- **Claude-3.5 Sonnet 适用场景**

  - 日常代码编写（常规功能和组件的开发）
  - 中等复杂度任务（既不太简单也不特别复杂的开发工作）
  - 代码优化与重构（改进现有代码但不涉及大规模架构变更）
  - 文档生成（自动生成各种形式的技术文档）
  - 需要较快响应的中等复杂任务（平衡质量和速度）

  **实际案例**：

  - "编写一个 React 组件，实现带有分页和搜索功能的数据表格"
  - "优化这个 MongoDB 查询，提高响应速度"
  - "为这个 API 生成完整的 Swagger 文档"
  - "实现一个基于 JWT 的身份验证系统"

- **Claude-3.5 Haiku 适用场景**

  - 简单代码补全（快速完成简单的代码片段）
  - 快速代码片段生成（小型函数或工具方法）
  - 基础代码修改（小范围的代码调整）
  - 紧急场景（需要立即获得回应）
  - 简单任务（逻辑清晰、范围有限的问题）
  - 编码过程中的实时辅助（类似自动补全但更智能）

  **实际案例**：

  - "编写一个函数，将日期字符串转换为 ISO 格式"
  - "创建一个简单的表单验证函数"
  - "修复这个 CSS 布局问题"
  - "编写一个简单的 API 请求函数"

- **GPT-4.1 适用场景**

  - 复杂算法实现（特别是涉及数学和逻辑推理的算法）
  - 深度推理任务（需要多步骤思考和问题解析）
  - 跨语言代码转换（完整项目或复杂功能的语言迁移）
  - 创造性解决方案（寻找非常规的创新方法）

  **实际案例**：

  - "设计一个机器学习模型的实现方案，包括数据预处理、特征工程和模型评估"
  - "将这个 Java 应用完整转换为 Kotlin，保持相同的功能和结构"
  - "为这个问题设计一个创新的解决方案，考虑非传统的方法"
  - "实现一个自定义的加密算法，满足特定的安全需求"

- **GPT-3.5 适用场景**

  - 日常简单编码（基础功能和简单脚本）
  - 小型重构任务（局部代码改进）
  - 代码补全和提示（编写过程中的辅助）
  - 基础代码优化（简单性能或可读性改进）
  - 标准文档生成（基本的注释和说明文档）
  - 快速原型开发（快速验证想法的代码原型）

  **实际案例**：

  - "编写一个简单的登录表单组件"
  - "优化这个 for 循环，提高执行效率"
  - "生成一个基本的 README 文件，描述项目功能和安装步骤"
  - "创建一个简单的 REST API 端点"

- **Gemini Pro 适用场景**
  - 多模态任务（结合代码和图像的分析）
  - 视觉理解开发（处理设计图和截图）
  - 跨领域知识整合（综合多个技术领域的解决方案）
  - 创新应用开发（前沿技术探索和实验）
  - 图形界面和视觉元素处理（UI/UX 开发）
    **实际案例**：
  - "分析这个 UI 设计图，生成对应的 React 组件代码"
  - "查看这个错误截图，诊断可能的原因并提供解决方案"
  - "将这个流程图转换为工作流代码"
  - "基于这个产品原型图，生成对应的前端实现"

### 模型选择策略

1. **任务复杂度匹配**

   - 简单任务：Claude-3.5 Haiku 或 GPT-3.5
   - 中等复杂度：Claude-3.5 Sonnet 或 GPT-4
   - 高复杂度：Claude-3.7 Sonnet 或 GPT-4.1

2. **响应时间考量**

   - 需要快速响应：选择 Haiku 模型
   - 可接受较长等待：选择 Sonnet 或 GPT-4.1 模型

3. **阶段性选择**

   - 项目初期探索：使用高级模型（Claude-3.7 Sonnet）
   - 日常开发实现：使用中级模型（Claude-3.5 Sonnet）
   - 简单修改和补充：使用轻量模型（Claude-3.5 Haiku）

4. **多模型协作**
   - 对同一问题使用不同模型生成解决方案
   - 比较不同模型的输出质量和思路
   - 综合多个模型的优点形成最终方案

## Mode Menu

Cursor 提供三种不同的交互模式，每种模式适合不同的工作场景和需求。根据任务性质选择合适的模式，可显著提升工作效率：

- **Agent 模式**

  - 适合复杂任务的自主协作（AI 会主动思考并规划多步解决方案）
  - 支持多步骤连续代码生成（处理大型功能或完整项目）
  - 提供自主决策和规划能力（分析需求、设计解决方案、实现并修正）
  - 适合复杂重构和架构调整（大规模代码改进）

  #### 典型使用场景

  - **功能开发**：描述"我需要实现一个用户认证系统，包括注册、登录和密码重置功能"
  - **代码重构**："帮我重构这个组件，将业务逻辑与 UI 分离"
  - **问题排查**："分析这段代码的性能问题并提供优化方案"
  - **项目设计**："帮我设计一个博客系统的数据库架构和 API"

- **Ask 模式**

  - 适合快速获取代码建议（简短而直接的答案）
  - 提供简单问题的即时解答（技术概念解释、API 用法等）
  - 生成独立的代码片段（小函数、工具方法等）
  - 进行快速代码审查和检查（语法错误、最佳实践等）
  - 提供最快的响应速度（立即得到回复）

  #### 典型使用场景

  - **快速问答**："如何在 React 中使用 useEffect？"
  - **代码解释**："这段正则表达式的作用是什么？"
  - **简单补全**："帮我写一个函数将日期格式化为 YYYY-MM-DD"
  - **概念解释**："解释一下闭包的概念和用途"
  - **参数查询**："Node.js 的 fs.readFile 方法有哪些参数？"

- **Manual 模式**

  - 提供完全控制 AI 行为的能力（精确指导 AI 执行特定任务）
  - 支持精准的代码修改和指令执行（按照你的确切要求行动）
  - 适合需要特定格式的输出（自定义输出结构和风格）
  - 适合需要精确控制的场景（严格按照指示行动而不添加额外内容）

  #### 典型使用场景

  - **精确指导**："将这个函数改为箭头函数，保持所有其他逻辑不变"
  - **特定格式**："生成一个 JSON 格式的 API 响应示例，包含用户 ID、名称和权限字段"
  - **分步执行**："先分析这段代码，然后告诉我它的复杂度，最后提供优化建议"
  - **严格控制**："只修改第 10-15 行的代码，其他部分保持不变"

### 模式选择技巧

- **任务复杂度**：复杂项目选择 Agent，简单快速查询选择 Ask，需要精确控制选择 Manual
- **交互频率**：频繁小互动用 Ask，长时间多步骤开发用 Agent
- **上下文重要性**：需要 AI 理解大量上下文和项目背景时用 Agent
- **精确度需求**：需要 AI 严格按照指示一步步执行时用 Manual
- **时间考量**：紧急快速的询问用 Ask，有充分时间的复杂任务用 Agent
- **迭代次数**：预计需要多次反复调整的任务用 Agent，一次性问答用 Ask

## MCP

Multi-Conversation Playground (MCP) 是 Cursor 的多对话管理功能，帮助你同时处理多个不同的任务和主题。

### 如何使用 MCP

1. **访问 MCP**

   - 直接访问 [mcp.so](https://mcp.so) 网站
   - 或在 Cursor 编辑器中点击左侧栏的聊天图标，切换到对话模式

2. **创建新对话**

   - 点击"+"按钮创建新的对话
   - 为对话设置清晰的标题，反映其主题或目标
   - 选择适合任务的 AI 模型（Claude 3.7 Sonnet、GPT-4.1 等）

3. **组织对话**

   - 使用标签功能给对话分类（如"前端"、"后端"、"学习"）
   - 创建对话组（文件夹）整理相关对话
   - 使用置顶功能将重要对话固定在顶部

4. **管理上下文**

   - 使用"Add Context"功能添加相关文件、代码或文档
   - 通过"Notepads"保存关键信息，在多个对话间共享
   - 利用"Past Chats"引用之前的对话内容

5. **导出与分享**
   - 使用导出功能将对话保存为 Markdown 或 JSON 格式
   - 通过分享链接与团队成员共享特定对话
   - 在 GitHub Copilot Chat 中分享对话链接

### 相关资源与工具

- **官方网站**: [mcp.so](https://mcp.so) - 在浏览器中直接访问 Cursor 的 MCP 功能
- **MCP 文档**: [Cursor 文档](https://cursor.sh/docs/mcp) - 详细的使用指南和最佳实践
- **MCP 社区**: [Discord 社区](https://discord.gg/cursor) - 交流 MCP 使用技巧和经验
- **插件生态**: [MCP 插件市场](https://cursor.sh/plugins) - 扩展 MCP 功能的插件

### MCP Pro 功能

- **无限对话历史** - 保存所有对话记录，无需担心丢失有价值的内容
- **更大的上下文窗口** - 处理更复杂的任务和更大的代码库
- **高级 AI 模型** - 优先访问最新的 AI 模型，提高效率和质量
- **高级团队协作** - 团队成员间共享对话和上下文

### 使用场景

#### 需求：处理多个并行开发任务

- **解决方式**：
  - 为每个独立功能或模块创建单独的对话
  - 在各对话中添加相关上下文和文件
  - 使用标签功能组织不同主题的对话
  - 随时在不同对话间切换而不丢失上下文

#### 需求：技术调研与决策

- **解决方式**：
  - 创建专用对话探索不同技术方案
  - 在一个对话中研究方案 A，在另一个中研究方案 B
  - 使用不同的模型进行对比评估
  - 整合多个对话的结论形成最终决策

#### 需求：知识管理与团队协作

- **解决方式**：
  - 为项目不同方面创建主题对话（架构、API 设计、数据模型等）
  - 使用对话历史作为团队知识库
  - 将关键对话导出分享给团队成员
  - 为常见问题创建模板对话

### MCP 最佳实践

- 给每个对话设置清晰的标题和目标
- 使用标签系统对对话进行分类（如"前端"、"后端"、"调试"、"学习"）
- 定期整理和归档已完成的对话
- 使用对话内笔记功能记录关键信息
- 为复杂项目创建对话组，保持相关对话的组织性
- 使用搜索功能快速找到历史对话和解决方案
- 善用对话克隆功能，保留有价值的上下文，开始新的迭代

## Best Practices

### 代码开发场景

#### 需求：快速开发新功能

- **解决方式**：
  - 使用 Agent 模式 + Claude-3.7 Sonnet，先描述功能需求和项目上下文
  - 添加相关文件上下文（Add Context → Files & folders）
  - 明确指出要遵循的代码规范和项目架构
  - 分步引导 AI 生成代码，每步确认后再继续

#### 需求：理解复杂代码

- **解决方式**：
  - 选择复杂代码块，右键选择"Ask about selection"
  - 指定具体问题："解释这段代码的工作原理"或"这段代码的性能瓶颈在哪里"
  - 添加相关依赖文件作为上下文（Add Context → Code）
  - 对于大型代码库，使用 Claude-3.7 Sonnet 获得更深入的分析

#### 需求：代码重构

- **解决方式**：
  - 添加需要重构的文件和相关依赖（Add Context → Files & folders）
  - 使用 Agent 模式指定重构目标（提高可读性、性能优化、模块化等）
  - 要求 AI 先分析当前代码问题，再提供重构方案
  - 在重构前确认 AI 理解了当前代码结构和业务逻辑

#### 需求：修复错误和调试

- **解决方式**：
  - 添加错误信息和相关代码文件
  - 使用 Add Context → Linter errors 添加错误信息
  - 对于复杂错误，添加 Add Context → Terminals 的运行日志
  - 要求 AI 分析错误原因并提供修复建议

### 学习场景

#### 需求：学习新技术或框架

- **解决方式**：
  - 使用 Ask 模式提问特定技术概念
  - 要求提供代码示例和最佳实践
  - 请求 AI 生成学习路线图或推荐学习资源
  - 对于复杂技术，使用 Claude-3.7 Sonnet 获得更深入的解释

#### 需求：代码审查和学习最佳实践

- **解决方式**：
  - 添加需要审查的代码文件
  - 请求 AI 从代码质量、性能、安全性等方面进行评估
  - 要求提供改进建议和解释理由
  - 使用 Add Context → Cursor rules 添加项目规范

### 文档场景

#### 需求：生成文档

- **解决方式**：
  - 添加需要文档化的代码文件
  - 指定文档格式要求（JSDoc、TSDoc、Markdown 等）
  - 对于 API 文档，添加接口定义和使用示例
  - 明确文档的目标受众（开发者、用户、管理层等）

#### 需求：编写技术方案

- **解决方式**：
  - 使用 Agent 模式，描述项目背景和需求
  - 添加相关技术文档和代码作为参考
  - 要求 AI 提供架构设计、技术选型、实现路径等
  - 对于复杂方案，分步引导 AI 完成不同章节

### 协作交流场景

#### 需求：代码解释给团队成员

- **解决方式**：
  - 添加需要解释的代码和相关上下文
  - 指定解释的技术深度和目标受众
  - 要求 AI 提供通俗易懂的解释和可视化描述
  - 使用 Claude-3.7 Sonnet 获得更全面的解释

#### 需求：生成代码评审反馈

- **解决方式**：
  - 添加需要评审的代码（Add Context → Git）
  - 指定评审重点（功能性、可维护性、性能等）
  - 要求 AI 以友好建设性的语气提供反馈
  - 针对关键问题，请求 AI 提供具体改进示例

### 效率提升技巧

- 使用快捷键 Ctrl+K 快速唤起 AI 助手
- 定期清理对话历史，保持上下文清晰
- 为复杂任务创建专用 chat 会话，避免上下文混淆
- 使用 Add Context → Past chats 引用之前的解决方案
- 善用 Add Context → Notepads 记录临时想法和需求
- 对于重复任务，建立个人提示模板库
- 在探索性工作时使用 Claude-3.7 Sonnet，日常编码使用 Claude-3.5 Haiku

## 参考链接

### 官方资源

- [Cursor 官方网站](https://www.cursor.com/cn) - Cursor 编辑器的官方主页
- [Cursor 文档中心](https://docs.cursor.com/welcome) - 详细的使用说明和教程
- [Cursor GitHub 仓库](https://github.com/getcursor/cursor) - 开源代码和问题跟踪
- [Cursor 博客](https://www.cursor.com/cn/blog) - 最新功能和使用技巧

### Composer 相关

- [Composer 功能详解](https://cursor.sh/docs/composer) - 深入了解 AI 编辑功能
- [代码生成最佳实践](https://cursor.sh/blog/code-generation) - 如何有效使用 AI 生成代码
- [代码解释功能教程](https://cursor.sh/docs/explain) - 使用 AI 理解复杂代码

### Add Context 相关

- [上下文管理指南](https://cursor.sh/docs/context) - 如何有效管理代码上下文
- [文件和文件夹添加教程](https://cursor.sh/docs/files) - 管理项目文件结构
- [Git 集成使用指南](https://cursor.sh/docs/git) - 在 Cursor 中使用 Git 功能

### Models 相关

- [Claude 3.7 详细介绍](https://www.anthropic.com/news/claude-3-7-opus) - Anthropic 关于 Claude 3.7 的官方说明
- [Claude 3.5 模型系列](https://www.anthropic.com/news/claude-3-5-sonnet) - Claude 3.5 Sonnet 和 Haiku 的介绍
- [GPT 模型对比](https://openai.com/blog/new-models-and-developer-products-announced-at-devday) - OpenAI 的模型对比和选择指南
- [Gemini Pro 技术细节](https://ai.google/discover/gemini/) - Google Gemini 系列模型介绍

### Mode Menu 相关

- [Agent 模式详解](https://cursor.sh/docs/agent) - 如何使用 Agent 模式完成复杂任务
- [Ask 模式使用技巧](https://cursor.sh/docs/ask) - 快速问答模式的最佳实践
- [Manual 模式控制指南](https://cursor.sh/docs/manual) - 如何精确控制 AI 行为

### MCP 相关

- [MCP 官方网站](https://modelcontextprotocol.io/introduction) - Multi-Conversation Playground 浏览器访问入口
- [MCP 官方网站](https://mcp.so) - Multi-Conversation Playground 浏览器访问入口
- [MCP 高级功能指南](https://cursor.sh/docs/mcp-pro) - MCP Pro 版本功能详解
- [团队协作最佳实践](https://cursor.sh/docs/team) - 使用 MCP 进行团队协作
- [对话管理技巧](https://cursor.sh/blog/conversation-management) - 如何有效管理多个 AI 对话

### 视频教程

- [Cursor 官方 YouTube 频道](https://youtube.com/@cursor-sh) - 视频教程和演示
- [Cursor 入门指南视频](https://www.youtube.com/watch?v=3EGHjGc4q-g) - 新手上手教程
- [高级功能详解视频](https://www.youtube.com/watch?v=TDd9Tjwu8qs) - 探索 Cursor 的高级功能

### 社区资源

- [Cursor Discord 社区](https://discord.gg/cursor) - 用户讨论和问题解答
- [Cursor Twitter 账号](https://twitter.com/cursor_sh) - 最新动态和公告
- [Cursor Reddit 社区](https://www.reddit.com/r/cursorsh/) - 用户分享的使用技巧和经验

- [Cursor 集成 MCP 教程](https://www.bilibili.com/video/BV1WBG9zgECp/?share_source=copy_web&vd_source=1b5ef0d101f9d9249bb126d39ab8452c)

- [How to actually use Cursor right](https://x.com/ryolu_/status/1914384195138511142)

- 请保持对话语言为中文
- 我的操作系统是 macOS
- 请在函数生成时添加函数级注释，并在函数内部适当的位置添加逻辑注释、运行流程等
- 请在回到时配合 emoji

- [awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules)

`.cursor/rules/xxx.mdc`
